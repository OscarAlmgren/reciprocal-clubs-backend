// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"reciprocal-clubs-backend/pkg/shared/auth"
	"strconv"
	"time"
)

type Address struct {
	Street     string `json:"street"`
	City       string `json:"city"`
	State      string `json:"state"`
	PostalCode string `json:"postalCode"`
	Country    string `json:"country"`
}

type AddressInput struct {
	Street     string `json:"street"`
	City       string `json:"city"`
	State      string `json:"state"`
	PostalCode string `json:"postalCode"`
	Country    string `json:"country"`
}

type AgreementTerms struct {
	MaxVisitsPerMonth int          `json:"maxVisitsPerMonth"`
	ReciprocalFee     *float64     `json:"reciprocalFee,omitempty"`
	BlackoutDates     []*time.Time `json:"blackoutDates,omitempty"`
	SpecialConditions *string      `json:"specialConditions,omitempty"`
}

type AgreementTermsInput struct {
	MaxVisitsPerMonth int          `json:"maxVisitsPerMonth"`
	ReciprocalFee     *float64     `json:"reciprocalFee,omitempty"`
	BlackoutDates     []*time.Time `json:"blackoutDates,omitempty"`
	SpecialConditions *string      `json:"specialConditions,omitempty"`
}

type Analytics struct {
	Visits      *VisitAnalytics      `json:"visits"`
	Members     *MemberAnalytics     `json:"members"`
	Reciprocals *ReciprocalAnalytics `json:"reciprocals"`
}

type AuthPayload struct {
	Token        string     `json:"token"`
	RefreshToken string     `json:"refreshToken"`
	User         *auth.User `json:"user"`
	ExpiresAt    time.Time  `json:"expiresAt"`
}

type CastVoteInput struct {
	ProposalID string     `json:"proposalId"`
	Choice     VoteChoice `json:"choice"`
	Comment    *string    `json:"comment,omitempty"`
}

type CheckOutVisitInput struct {
	VisitID  string   `json:"visitId"`
	Services []string `json:"services,omitempty"`
	Cost     *float64 `json:"cost,omitempty"`
}

type Club struct {
	ID          string        `json:"id"`
	Name        string        `json:"name"`
	Description *string       `json:"description,omitempty"`
	Location    string        `json:"location"`
	Website     *string       `json:"website,omitempty"`
	Status      ClubStatus    `json:"status"`
	Settings    *ClubSettings `json:"settings,omitempty"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
}

type ClubSettings struct {
	AllowReciprocal   bool     `json:"allowReciprocal"`
	RequireApproval   bool     `json:"requireApproval"`
	MaxVisitsPerMonth int      `json:"maxVisitsPerMonth"`
	ReciprocalFee     *float64 `json:"reciprocalFee,omitempty"`
}

type ClubVisitCount struct {
	Club  *Club `json:"club"`
	Count int   `json:"count"`
}

type CreateMemberInput struct {
	UserID         string              `json:"userId"`
	MembershipType MembershipType      `json:"membershipType"`
	Profile        *MemberProfileInput `json:"profile"`
}

type CreateNotificationInput struct {
	UserIds     []string              `json:"userIds"`
	Type        NotificationType      `json:"type"`
	Title       string                `json:"title"`
	Message     string                `json:"message"`
	Channels    []NotificationChannel `json:"channels"`
	ScheduledAt *time.Time            `json:"scheduledAt,omitempty"`
}

type CreateProposalInput struct {
	Title          string       `json:"title"`
	Description    string       `json:"description"`
	Type           ProposalType `json:"type"`
	VotingDeadline time.Time    `json:"votingDeadline"`
}

type CreateReciprocalAgreementInput struct {
	PartnerClubID  string               `json:"partnerClubId"`
	Terms          *AgreementTermsInput `json:"terms"`
	EffectiveDate  time.Time            `json:"effectiveDate"`
	ExpirationDate *time.Time           `json:"expirationDate,omitempty"`
}

type EmergencyContact struct {
	Name         string `json:"name"`
	Relationship string `json:"relationship"`
	PhoneNumber  string `json:"phoneNumber"`
}

type EmergencyContactInput struct {
	Name         string `json:"name"`
	Relationship string `json:"relationship"`
	PhoneNumber  string `json:"phoneNumber"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Member struct {
	ID                 string         `json:"id"`
	ClubID             string         `json:"clubId"`
	UserID             string         `json:"userId"`
	MemberNumber       string         `json:"memberNumber"`
	MembershipType     MembershipType `json:"membershipType"`
	Status             MemberStatus   `json:"status"`
	BlockchainIdentity *string        `json:"blockchainIdentity,omitempty"`
	Profile            *MemberProfile `json:"profile,omitempty"`
	JoinedAt           time.Time      `json:"joinedAt"`
	CreatedAt          time.Time      `json:"createdAt"`
	UpdatedAt          time.Time      `json:"updatedAt"`
}

type MemberAnalytics struct {
	TotalMembers           int                    `json:"totalMembers"`
	ActiveMembers          int                    `json:"activeMembers"`
	NewMembersThisMonth    int                    `json:"newMembersThisMonth"`
	MembershipDistribution []*MembershipTypeCount `json:"membershipDistribution"`
}

type MemberConnection struct {
	Nodes    []*Member `json:"nodes"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type MemberPreferences struct {
	EmailNotifications bool `json:"emailNotifications"`
	SmsNotifications   bool `json:"smsNotifications"`
	PushNotifications  bool `json:"pushNotifications"`
	MarketingEmails    bool `json:"marketingEmails"`
}

type MemberPreferencesInput struct {
	EmailNotifications bool `json:"emailNotifications"`
	SmsNotifications   bool `json:"smsNotifications"`
	PushNotifications  bool `json:"pushNotifications"`
	MarketingEmails    bool `json:"marketingEmails"`
}

type MemberProfile struct {
	FirstName        string             `json:"firstName"`
	LastName         string             `json:"lastName"`
	DateOfBirth      *time.Time         `json:"dateOfBirth,omitempty"`
	PhoneNumber      *string            `json:"phoneNumber,omitempty"`
	Address          *Address           `json:"address,omitempty"`
	EmergencyContact *EmergencyContact  `json:"emergencyContact,omitempty"`
	Preferences      *MemberPreferences `json:"preferences,omitempty"`
}

type MemberProfileInput struct {
	FirstName        string                  `json:"firstName"`
	LastName         string                  `json:"lastName"`
	DateOfBirth      *time.Time              `json:"dateOfBirth,omitempty"`
	PhoneNumber      *string                 `json:"phoneNumber,omitempty"`
	Address          *AddressInput           `json:"address,omitempty"`
	EmergencyContact *EmergencyContactInput  `json:"emergencyContact,omitempty"`
	Preferences      *MemberPreferencesInput `json:"preferences,omitempty"`
}

type MembershipTypeCount struct {
	Type  MembershipType `json:"type"`
	Count int            `json:"count"`
}

type MonthlyVisit struct {
	Month string `json:"month"`
	Count int    `json:"count"`
}

type Mutation struct {
}

type Notification struct {
	ID          string                `json:"id"`
	UserID      string                `json:"userId"`
	Type        NotificationType      `json:"type"`
	Title       string                `json:"title"`
	Message     string                `json:"message"`
	Status      NotificationStatus    `json:"status"`
	Channels    []NotificationChannel `json:"channels"`
	ScheduledAt *time.Time            `json:"scheduledAt,omitempty"`
	SentAt      *time.Time            `json:"sentAt,omitempty"`
	ReadAt      *time.Time            `json:"readAt,omitempty"`
	CreatedAt   time.Time             `json:"createdAt"`
}

type NotificationConnection struct {
	Nodes    []*Notification `json:"nodes"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

type PageInfo struct {
	Page        int  `json:"page"`
	PageSize    int  `json:"pageSize"`
	Total       int  `json:"total"`
	TotalPages  int  `json:"totalPages"`
	HasNextPage bool `json:"hasNextPage"`
	HasPrevPage bool `json:"hasPrevPage"`
}

type PaginationInput struct {
	Page     *int `json:"page,omitempty"`
	PageSize *int `json:"pageSize,omitempty"`
}

type Proposal struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Type           ProposalType   `json:"type"`
	Status         ProposalStatus `json:"status"`
	Proposer       *auth.User     `json:"proposer"`
	Votes          []*Vote        `json:"votes"`
	VotingDeadline time.Time      `json:"votingDeadline"`
	CreatedAt      time.Time      `json:"createdAt"`
}

type ProposalConnection struct {
	Nodes    []*Proposal `json:"nodes"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

type Query struct {
}

type ReciprocalAgreement struct {
	ID             string          `json:"id"`
	ClubID         string          `json:"clubId"`
	PartnerClubID  string          `json:"partnerClubId"`
	Status         AgreementStatus `json:"status"`
	Terms          *AgreementTerms `json:"terms"`
	EffectiveDate  time.Time       `json:"effectiveDate"`
	ExpirationDate *time.Time      `json:"expirationDate,omitempty"`
	CreatedAt      time.Time       `json:"createdAt"`
	UpdatedAt      time.Time       `json:"updatedAt"`
}

type ReciprocalAgreementConnection struct {
	Nodes    []*ReciprocalAgreement `json:"nodes"`
	PageInfo *PageInfo              `json:"pageInfo"`
}

type ReciprocalAnalytics struct {
	TotalAgreements        int             `json:"totalAgreements"`
	ActiveAgreements       int             `json:"activeAgreements"`
	PendingAgreements      int             `json:"pendingAgreements"`
	MonthlyReciprocalUsage []*MonthlyVisit `json:"monthlyReciprocalUsage"`
}

type RecordVisitInput struct {
	MemberID       string   `json:"memberId"`
	VisitingClubID string   `json:"visitingClubId"`
	Services       []string `json:"services,omitempty"`
	Cost           *float64 `json:"cost,omitempty"`
}

type RegisterInput struct {
	Email     string `json:"email"`
	Password  string `json:"password"`
	Username  string `json:"username"`
	ClubID    string `json:"clubId"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

type Subscription struct {
}

type Transaction struct {
	ID          string            `json:"id"`
	Type        TransactionType   `json:"type"`
	Chaincode   string            `json:"chaincode"`
	Function    string            `json:"function"`
	Args        []string          `json:"args"`
	Status      TransactionStatus `json:"status"`
	TxID        *string           `json:"txId,omitempty"`
	BlockNumber *int              `json:"blockNumber,omitempty"`
	Timestamp   *time.Time        `json:"timestamp,omitempty"`
	Error       *string           `json:"error,omitempty"`
	CreatedAt   time.Time         `json:"createdAt"`
}

type Visit struct {
	ID             string      `json:"id"`
	MemberID       string      `json:"memberId"`
	ClubID         string      `json:"clubId"`
	VisitingClubID string      `json:"visitingClubId"`
	Status         VisitStatus `json:"status"`
	CheckInTime    time.Time   `json:"checkInTime"`
	CheckOutTime   *time.Time  `json:"checkOutTime,omitempty"`
	Services       []string    `json:"services,omitempty"`
	Cost           *float64    `json:"cost,omitempty"`
	Verified       bool        `json:"verified"`
	BlockchainTxID *string     `json:"blockchainTxId,omitempty"`
	CreatedAt      time.Time   `json:"createdAt"`
}

type VisitAnalytics struct {
	TotalVisits          int               `json:"totalVisits"`
	MonthlyVisits        []*MonthlyVisit   `json:"monthlyVisits"`
	TopDestinations      []*ClubVisitCount `json:"topDestinations"`
	AverageVisitDuration *float64          `json:"averageVisitDuration,omitempty"`
}

type VisitConnection struct {
	Nodes    []*Visit  `json:"nodes"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type Vote struct {
	ID         string     `json:"id"`
	ProposalID string     `json:"proposalId"`
	Voter      *auth.User `json:"voter"`
	Choice     VoteChoice `json:"choice"`
	Comment    *string    `json:"comment,omitempty"`
	CreatedAt  time.Time  `json:"createdAt"`
}

type AgreementStatus string

const (
	AgreementStatusPending   AgreementStatus = "PENDING"
	AgreementStatusApproved  AgreementStatus = "APPROVED"
	AgreementStatusActive    AgreementStatus = "ACTIVE"
	AgreementStatusSuspended AgreementStatus = "SUSPENDED"
	AgreementStatusExpired   AgreementStatus = "EXPIRED"
	AgreementStatusRejected  AgreementStatus = "REJECTED"
)

var AllAgreementStatus = []AgreementStatus{
	AgreementStatusPending,
	AgreementStatusApproved,
	AgreementStatusActive,
	AgreementStatusSuspended,
	AgreementStatusExpired,
	AgreementStatusRejected,
}

func (e AgreementStatus) IsValid() bool {
	switch e {
	case AgreementStatusPending, AgreementStatusApproved, AgreementStatusActive, AgreementStatusSuspended, AgreementStatusExpired, AgreementStatusRejected:
		return true
	}
	return false
}

func (e AgreementStatus) String() string {
	return string(e)
}

func (e *AgreementStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AgreementStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AgreementStatus", str)
	}
	return nil
}

func (e AgreementStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ClubStatus string

const (
	ClubStatusActive    ClubStatus = "ACTIVE"
	ClubStatusInactive  ClubStatus = "INACTIVE"
	ClubStatusSuspended ClubStatus = "SUSPENDED"
)

var AllClubStatus = []ClubStatus{
	ClubStatusActive,
	ClubStatusInactive,
	ClubStatusSuspended,
}

func (e ClubStatus) IsValid() bool {
	switch e {
	case ClubStatusActive, ClubStatusInactive, ClubStatusSuspended:
		return true
	}
	return false
}

func (e ClubStatus) String() string {
	return string(e)
}

func (e *ClubStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClubStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClubStatus", str)
	}
	return nil
}

func (e ClubStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MemberStatus string

const (
	MemberStatusActive    MemberStatus = "ACTIVE"
	MemberStatusInactive  MemberStatus = "INACTIVE"
	MemberStatusSuspended MemberStatus = "SUSPENDED"
	MemberStatusPending   MemberStatus = "PENDING"
)

var AllMemberStatus = []MemberStatus{
	MemberStatusActive,
	MemberStatusInactive,
	MemberStatusSuspended,
	MemberStatusPending,
}

func (e MemberStatus) IsValid() bool {
	switch e {
	case MemberStatusActive, MemberStatusInactive, MemberStatusSuspended, MemberStatusPending:
		return true
	}
	return false
}

func (e MemberStatus) String() string {
	return string(e)
}

func (e *MemberStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberStatus", str)
	}
	return nil
}

func (e MemberStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MembershipType string

const (
	MembershipTypeRegular   MembershipType = "REGULAR"
	MembershipTypePremium   MembershipType = "PREMIUM"
	MembershipTypeLifetime  MembershipType = "LIFETIME"
	MembershipTypeCorporate MembershipType = "CORPORATE"
)

var AllMembershipType = []MembershipType{
	MembershipTypeRegular,
	MembershipTypePremium,
	MembershipTypeLifetime,
	MembershipTypeCorporate,
}

func (e MembershipType) IsValid() bool {
	switch e {
	case MembershipTypeRegular, MembershipTypePremium, MembershipTypeLifetime, MembershipTypeCorporate:
		return true
	}
	return false
}

func (e MembershipType) String() string {
	return string(e)
}

func (e *MembershipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MembershipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MembershipType", str)
	}
	return nil
}

func (e MembershipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationChannel string

const (
	NotificationChannelEmail NotificationChannel = "EMAIL"
	NotificationChannelSms   NotificationChannel = "SMS"
	NotificationChannelPush  NotificationChannel = "PUSH"
	NotificationChannelInApp NotificationChannel = "IN_APP"
)

var AllNotificationChannel = []NotificationChannel{
	NotificationChannelEmail,
	NotificationChannelSms,
	NotificationChannelPush,
	NotificationChannelInApp,
}

func (e NotificationChannel) IsValid() bool {
	switch e {
	case NotificationChannelEmail, NotificationChannelSms, NotificationChannelPush, NotificationChannelInApp:
		return true
	}
	return false
}

func (e NotificationChannel) String() string {
	return string(e)
}

func (e *NotificationChannel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationChannel", str)
	}
	return nil
}

func (e NotificationChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationStatus string

const (
	NotificationStatusPending   NotificationStatus = "PENDING"
	NotificationStatusSent      NotificationStatus = "SENT"
	NotificationStatusDelivered NotificationStatus = "DELIVERED"
	NotificationStatusRead      NotificationStatus = "READ"
	NotificationStatusFailed    NotificationStatus = "FAILED"
)

var AllNotificationStatus = []NotificationStatus{
	NotificationStatusPending,
	NotificationStatusSent,
	NotificationStatusDelivered,
	NotificationStatusRead,
	NotificationStatusFailed,
}

func (e NotificationStatus) IsValid() bool {
	switch e {
	case NotificationStatusPending, NotificationStatusSent, NotificationStatusDelivered, NotificationStatusRead, NotificationStatusFailed:
		return true
	}
	return false
}

func (e NotificationStatus) String() string {
	return string(e)
}

func (e *NotificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationStatus", str)
	}
	return nil
}

func (e NotificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationType string

const (
	NotificationTypeSystem     NotificationType = "SYSTEM"
	NotificationTypeMembership NotificationType = "MEMBERSHIP"
	NotificationTypeReciprocal NotificationType = "RECIPROCAL"
	NotificationTypeVisit      NotificationType = "VISIT"
	NotificationTypeBilling    NotificationType = "BILLING"
	NotificationTypeSecurity   NotificationType = "SECURITY"
)

var AllNotificationType = []NotificationType{
	NotificationTypeSystem,
	NotificationTypeMembership,
	NotificationTypeReciprocal,
	NotificationTypeVisit,
	NotificationTypeBilling,
	NotificationTypeSecurity,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeSystem, NotificationTypeMembership, NotificationTypeReciprocal, NotificationTypeVisit, NotificationTypeBilling, NotificationTypeSecurity:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProposalStatus string

const (
	ProposalStatusDraft       ProposalStatus = "DRAFT"
	ProposalStatusVoting      ProposalStatus = "VOTING"
	ProposalStatusPassed      ProposalStatus = "PASSED"
	ProposalStatusRejected    ProposalStatus = "REJECTED"
	ProposalStatusImplemented ProposalStatus = "IMPLEMENTED"
)

var AllProposalStatus = []ProposalStatus{
	ProposalStatusDraft,
	ProposalStatusVoting,
	ProposalStatusPassed,
	ProposalStatusRejected,
	ProposalStatusImplemented,
}

func (e ProposalStatus) IsValid() bool {
	switch e {
	case ProposalStatusDraft, ProposalStatusVoting, ProposalStatusPassed, ProposalStatusRejected, ProposalStatusImplemented:
		return true
	}
	return false
}

func (e ProposalStatus) String() string {
	return string(e)
}

func (e *ProposalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalStatus", str)
	}
	return nil
}

func (e ProposalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProposalType string

const (
	ProposalTypeAgreementChange ProposalType = "AGREEMENT_CHANGE"
	ProposalTypePolicyUpdate    ProposalType = "POLICY_UPDATE"
	ProposalTypeFeeAdjustment   ProposalType = "FEE_ADJUSTMENT"
	ProposalTypeSystemUpgrade   ProposalType = "SYSTEM_UPGRADE"
)

var AllProposalType = []ProposalType{
	ProposalTypeAgreementChange,
	ProposalTypePolicyUpdate,
	ProposalTypeFeeAdjustment,
	ProposalTypeSystemUpgrade,
}

func (e ProposalType) IsValid() bool {
	switch e {
	case ProposalTypeAgreementChange, ProposalTypePolicyUpdate, ProposalTypeFeeAdjustment, ProposalTypeSystemUpgrade:
		return true
	}
	return false
}

func (e ProposalType) String() string {
	return string(e)
}

func (e *ProposalType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProposalType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProposalType", str)
	}
	return nil
}

func (e ProposalType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionStatus string

const (
	TransactionStatusPending   TransactionStatus = "PENDING"
	TransactionStatusSubmitted TransactionStatus = "SUBMITTED"
	TransactionStatusConfirmed TransactionStatus = "CONFIRMED"
	TransactionStatusFailed    TransactionStatus = "FAILED"
)

var AllTransactionStatus = []TransactionStatus{
	TransactionStatusPending,
	TransactionStatusSubmitted,
	TransactionStatusConfirmed,
	TransactionStatusFailed,
}

func (e TransactionStatus) IsValid() bool {
	switch e {
	case TransactionStatusPending, TransactionStatusSubmitted, TransactionStatusConfirmed, TransactionStatusFailed:
		return true
	}
	return false
}

func (e TransactionStatus) String() string {
	return string(e)
}

func (e *TransactionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionStatus", str)
	}
	return nil
}

func (e TransactionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionType string

const (
	TransactionTypeMemberRegistration TransactionType = "MEMBER_REGISTRATION"
	TransactionTypeVisitRecord        TransactionType = "VISIT_RECORD"
	TransactionTypeAgreementCreation  TransactionType = "AGREEMENT_CREATION"
	TransactionTypePaymentRecord      TransactionType = "PAYMENT_RECORD"
)

var AllTransactionType = []TransactionType{
	TransactionTypeMemberRegistration,
	TransactionTypeVisitRecord,
	TransactionTypeAgreementCreation,
	TransactionTypePaymentRecord,
}

func (e TransactionType) IsValid() bool {
	switch e {
	case TransactionTypeMemberRegistration, TransactionTypeVisitRecord, TransactionTypeAgreementCreation, TransactionTypePaymentRecord:
		return true
	}
	return false
}

func (e TransactionType) String() string {
	return string(e)
}

func (e *TransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionType", str)
	}
	return nil
}

func (e TransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserStatus string

const (
	UserStatusActive              UserStatus = "ACTIVE"
	UserStatusInactive            UserStatus = "INACTIVE"
	UserStatusSuspended           UserStatus = "SUSPENDED"
	UserStatusPendingVerification UserStatus = "PENDING_VERIFICATION"
)

var AllUserStatus = []UserStatus{
	UserStatusActive,
	UserStatusInactive,
	UserStatusSuspended,
	UserStatusPendingVerification,
}

func (e UserStatus) IsValid() bool {
	switch e {
	case UserStatusActive, UserStatusInactive, UserStatusSuspended, UserStatusPendingVerification:
		return true
	}
	return false
}

func (e UserStatus) String() string {
	return string(e)
}

func (e *UserStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserStatus", str)
	}
	return nil
}

func (e UserStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VisitStatus string

const (
	VisitStatusCheckedIn  VisitStatus = "CHECKED_IN"
	VisitStatusCheckedOut VisitStatus = "CHECKED_OUT"
	VisitStatusCancelled  VisitStatus = "CANCELLED"
	VisitStatusNoShow     VisitStatus = "NO_SHOW"
)

var AllVisitStatus = []VisitStatus{
	VisitStatusCheckedIn,
	VisitStatusCheckedOut,
	VisitStatusCancelled,
	VisitStatusNoShow,
}

func (e VisitStatus) IsValid() bool {
	switch e {
	case VisitStatusCheckedIn, VisitStatusCheckedOut, VisitStatusCancelled, VisitStatusNoShow:
		return true
	}
	return false
}

func (e VisitStatus) String() string {
	return string(e)
}

func (e *VisitStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VisitStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VisitStatus", str)
	}
	return nil
}

func (e VisitStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteChoice string

const (
	VoteChoiceYes     VoteChoice = "YES"
	VoteChoiceNo      VoteChoice = "NO"
	VoteChoiceAbstain VoteChoice = "ABSTAIN"
)

var AllVoteChoice = []VoteChoice{
	VoteChoiceYes,
	VoteChoiceNo,
	VoteChoiceAbstain,
}

func (e VoteChoice) IsValid() bool {
	switch e {
	case VoteChoiceYes, VoteChoiceNo, VoteChoiceAbstain:
		return true
	}
	return false
}

func (e VoteChoice) String() string {
	return string(e)
}

func (e *VoteChoice) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteChoice(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteChoice", str)
	}
	return nil
}

func (e VoteChoice) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
